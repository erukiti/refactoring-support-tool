* 静的に計算できるものは全部計算すべき
  * 変な hack をしない限り、関数呼び出しも全部インライン展開してもいいはず

ASTのみから、全部手で解析しようとした場合、スコープ対応は自前でやらないといけないが、どうせファイル処理とかも考えたらそれはそれで、仕方ない気がする

## 段階的に作っていく

1. まず1ファイル完結のコードを対象にする

## どうやって実現する？

コードのもっともシンプルな状態を導き出せれば、それをハッシュ化とかできないか？

### 解析時に静的に計算できるもの

```ts
const a = 1 + 2
console.log(a)
```

とかを、`console.log(3)` 呼び出しだけに変換する？
これはやっておくべきなので、静的に計算できるものは全部計算しておく

### 関数呼び出しとか

関数ごとに、中身を一番シンプルにした状態のハッシュをとっておく？
それはできるかもしれないけど、結構めんどそう

関数の中身を全部インライン展開しちゃっていいのでは？

もしかしたらその中身処理の最適化でいい方法を思いつくかも

### 1passでできる？

コルーチン使うか、2passにするか?

### どういう形式にすればいいのか？

今回作りたいリファクタリング支援ソフトだけでいえば一番シンプルにしたもののハッシュ値か何かがあればよい

たとえば `sha256('console.log(3)')` とか？

ありかも？表記揺れになりそうなのは空行抜きで、prettier か何か基準にする？

`console.log(3)` と `console.log(1 + 2)` や `const a = 1 + 2; console.log(a)` がそれぞれ同一になるためにはどうすればいいのか？

考えかた、ローカルで定義されてるものは全部インライン展開する `const a` とか。計算できるものも全部インライン展開する。

として、どうやればインライン展開できる？traverse で最深部から変換かます？戻り値は何？

ASTはASTで別途保持してるところに対するポインタでいいとする。インデックスとかを持つこともできるかもしれないが、持つ意味ができてから考えればいいので、単純に、ASTの特定部分を、ポインタとしてもっておく（持ってなくてもいいかもしれないけど）

まず目指すべきところは、ハッシュを取る為のソースコードを生成できること？

`console.log` は意外に複雑だから、起点は、`alert(3)` とかがいいかも？

callee が Identifier に収束できて、かつ Identifier が未知の物なら、その時点でクリティカルパスであることが分かる

callee が 既知の Identifier （と言ってもスコープの都合がある）ならば、インライン展開の対象になる

再帰呼び出しで、return するの前提にする？それとも、共有変数に push していく？ `CallExpression` を見つけたら、push する方がやりやすいのは確かな気がしたりしなかったり

再帰的に処理するのを考えると、戻り値は必要な気はする

ローカル定義する関数は、その関数の中身のコードをシグネーチャ化したハッシュ値を文字列としたものでいいかも（先頭に数字が来るのでそれ対策は必要。_でもつける？）とは思ったけど、リファクタリング支援のためって考えると一歩足りない。関数への外だしやインライン化のリファクタリングをした時に別物として扱われてしまいそう

とりあえず、traverse の戻り値を使うべき。たぶん

```ts
type Traversed = {
  code: string | undefined // ?
  ast: Node // pointer
}
```

`value` も必要？？？その場合、さらに type も必要になると思う

未解決の関数を使ってるときにどうする？generator使うのは、正直コーディング的にはしんどい。となると2pass?でも、それならそれで中間状態を示す何かがないといけない

が、まずは `1 + 2 + 3` を解決できる方が先かもしれない

`NumericLiteral` で code を返してるけど、code を undefined にして、 value を返すべきか？で、traverse 呼び出し側でそこを判定すべきか

`TraversedNumericLiteral` とかも作った方がよさそう？
`NumericValue` `StringValue` とかでいいような気がしたり

`DeclationNumericValue` とか作る？で、Program で合成するとか

Node 作り直しで `Node` もありかも？？解決不可能なときは Node を返して、Program が Node を返したら、もう一回 traverse 呼び出すとかでいいような気がする

var スコープって、相互参照ありえるのかな。より一層めんどいなこれ

とりあえず、解読しながら、global state 持つ必要あるかも？

analysingState を持つか、持つのはありだと思う

callState みたいなのを持つべきか。`const a = () => 3` みたいなコードをどう取り扱うべきなのか？`ArrowFunctionExpression`の処理にときにわりと困る。

Program を処理するための関数みたいなのを外に作って、それを ArrowFunctionExpression の body とかで実行するとか？

あ、スコープのことを忘れてた…………
anylysingState.declarations の取得や更新を関数化しておくか。
blockScope とトップレベルスコープみたいなのを分けておけばよさそう？getFromDeclarationsみたいなので吸収

ReturnStatement どうしたものか……
コードが死ぬほどややこしくなってきたので、中間層を設けたいがどうしたものか？

とりあえず、解決したいこと

* ブロックの中身をどう扱うか。if とか入ってくると return がめんどいよねきっと
* `CallExpression` の処理が大分アレになってきてる
* そろそろリファクタリングしたい。TDDで追加しまくってるけど、ややこしいコードになってきた。まぁもうちょっとコード追加してけば、思いつくことも色々ありそう

んー、変数の参照も、関数の呼び出しも同じにすればいいのでは。関数の呼び出しは引数がからむだけ。どっちにしても `Node` が存在するものならその時点で解決をしなければいけないサムシングがあるはず

スコープは、

* local scope
* varBlock scope
* named
* globalとか

の4種類を管理すればいい気がする。named は、import や export がからむやつ。あとクラスが絡んできたらメソッド名とかも？

ただ、named はリファクタリングできなくなるから、さらにもう一段階くらい必要になるかも？たとえば、package local なやつは rename 可能な仕組みにするとか

あー。import from がローカルパスなら、ローカルスコープとして rename 可能な扱いで良い。パッケージのパスとか http とかなら rename できない。

export は、いったん忘れた方がよさそう。複数ファイル対応の時点で改めて考え直すべき

クロージャがあるか……。とはいえ、関数が定義された時点の変数に束縛されるってのをミスらなければいいような？再代入がある場合にめんどいけど、再代入は、何か別の考え方で管理したい（Rust が let でシャドウイングできるのと同じように扱えるのでは）

引数の処理をどうする？スコープに、args を追加でいい気がした

スコープのスタックも考えないといけないけどどうするか

AnalysingState をクラス化するか…………

traverse option やっぱり必要かなー
anaylysingState.stateStackでは、function が多重になった時にあかん
と思ったけど、state に、running を追加と、argScope を追加しちゃえばいいのでは
