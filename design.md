* 静的に計算できるものは全部計算すべき
  * 変な hack をしない限り、関数呼び出しも全部インライン展開してもいいはず

ASTのみから、全部手で解析しようとした場合、スコープ対応は自前でやらないといけないが、どうせファイル処理とかも考えたらそれはそれで、仕方ない気がする

## 段階的に作っていく

1. まず1ファイル完結のコードを対象にする

## どうやって実現する？

コードのもっともシンプルな状態を導き出せれば、それをハッシュ化とかできないか？

### 解析時に静的に計算できるもの

```ts
const a = 1 + 2
console.log(a)
```

とかを、`console.log(3)` 呼び出しだけに変換する？
これはやっておくべきなので、静的に計算できるものは全部計算しておく

### 関数呼び出しとか

関数ごとに、中身を一番シンプルにした状態のハッシュをとっておく？
それはできるかもしれないけど、結構めんどそう

関数の中身を全部インライン展開しちゃっていいのでは？

もしかしたらその中身処理の最適化でいい方法を思いつくかも

### 1passでできる？

コルーチン使うか、2passにするか?

### どういう形式にすればいいのか？

今回作りたいリファクタリング支援ソフトだけでいえば一番シンプルにしたもののハッシュ値か何かがあればよい

たとえば `sha256('console.log(3)')` とか？

ありかも？表記揺れになりそうなのは空行抜きで、prettier か何か基準にする？

`console.log(3)` と `console.log(1 + 2)` や `const a = 1 + 2; console.log(a)` がそれぞれ同一になるためにはどうすればいいのか？

考えかた、ローカルで定義されてるものは全部インライン展開する `const a` とか。計算できるものも全部インライン展開する。

として、どうやればインライン展開できる？traverse で最深部から変換かます？戻り値は何？

ASTはASTで別途保持してるところに対するポインタでいいとする。インデックスとかを持つこともできるかもしれないが、持つ意味ができてから考えればいいので、単純に、ASTの特定部分を、ポインタとしてもっておく（持ってなくてもいいかもしれないけど）

まず目指すべきところは、ハッシュを取る為のソースコードを生成できること？

`console.log` は意外に複雑だから、起点は、`alert(3)` とかがいいかも？

callee が Identifier に収束できて、かつ Identifier が未知の物なら、その時点でクリティカルパスであることが分かる

callee が 既知の Identifier （と言ってもスコープの都合がある）ならば、インライン展開の対象になる

再帰呼び出しで、return するの前提にする？それとも、共有変数に push していく？ `CallExpression` を見つけたら、push する方がやりやすいのは確かな気がしたりしなかったり

再帰的に処理するのを考えると、戻り値は必要な気はする

ローカル定義する関数は、その関数の中身のコードをシグネーチャ化したハッシュ値を文字列としたものでいいかも（先頭に数字が来るのでそれ対策は必要。_でもつける？）とは思ったけど、リファクタリング支援のためって考えると一歩足りない。関数への外だしやインライン化のリファクタリングをした時に別物として扱われてしまいそう

とりあえず、traverse の戻り値を使うべき。たぶん

```ts
type Traversed = {
  code: string | undefined // ?
  ast: Node // pointer
}
```

`value` も必要？？？その場合、さらに type も必要になると思う

未解決の関数を使ってるときにどうする？generator使うのは、正直コーディング的にはしんどい。となると2pass?でも、それならそれで中間状態を示す何かがないといけない

が、まずは `1 + 2 + 3` を解決できる方が先かもしれない

`NumericLiteral` で code を返してるけど、code を undefined にして、 value を返すべきか？で、traverse 呼び出し側でそこを判定すべきか

`TraversedNumericLiteral` とかも作った方がよさそう？